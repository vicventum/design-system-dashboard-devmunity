---
description: Coding conventions for Vue components using TypeScript and Script Setup
globs: **/*.vue
alwaysApply: false
---
# Vue Component TypeScript Conventions

> **Note**: This rule applies specifically to components whose `setup` tag is `type="ts"` (i.e., components that use TypeScript).

## Script Section

- **Tag**: Use `<script lang="ts" setup>`.
- **Imports**: Import types for Nuxt/UI components from `#components`.
  ```typescript
  import type { UButton } from '#components'
  ```

## Types and Interfaces

- **Derived Types**: Use `InstanceType<typeof Component>['$props']['propName']` to derive valid values from underlying components (e.g., Nuxt UI components).
- **Export Types**: Export these derived types if they are useful for consumers.
  ```typescript
  export type ButtonSize = InstanceType<typeof UButton>['$props']['size']
  ```
- **Props Interface**: Define a typed `interface Props`.
  - Use JSDoc `/** ... */` comments for documentation.
  - Use `?` for optional props.
  - Use `is` or `has` prefixes for boolean props (e.g., `isOpen`, `hasIcon`).
  ```typescript
  interface Props {
      /**
       * Description of the prop
       */
      size?: ButtonSize
  }
  ```

## Component Options (Props, Emits, Slots)

- **Props**: Use `withDefaults` and `defineProps<Props>()`.
  ```typescript
  const props = withDefaults(defineProps<Props>(), {
      size: 'md'
  })
  ```
- **Slots**: Use `defineSlots` to strictly type slots.
  - Use JSDoc to describe the slot's content or purpose.
  ```typescript
  defineSlots<{
      /**
       * The default slot content
       */
      default(): any
  }>()
  ```
- **Emits**: Use `defineEmits` with the call signature syntax.
  - Event names should be `kebab-case`.
  - Use JSDoc to describe when the event is emitted.
  ```typescript
  const emit = defineEmits<{
      /**
       * Emitted when the user clicks the element
       */
      (e: 'on-click'): void
  }>()
  ```

## Template

- Use `kebab-case` for custom event listeners (e.g., `@on-click`).
- When wrapping components, pass props effectively (e.g., using object binding for complex sub-props like `:avatar="{ src, size }" `).
- Use the `:ui` prop to override internal component styles, often referencing computed properties for complexity.

## Logic & Computed Styles

- **Class Mappings**: Use `computed` properties with a map object (e.g., `sizeMap`) to handle complex prop-to-class logic instead of inline templates.
  ```typescript
  const textSize = computed(() => {
      const sizeMap = {
          sm: 'text-xs',
          md: 'text-sm'
      }
      return sizeMap[props.size] || 'text-sm'
  })
  ```
